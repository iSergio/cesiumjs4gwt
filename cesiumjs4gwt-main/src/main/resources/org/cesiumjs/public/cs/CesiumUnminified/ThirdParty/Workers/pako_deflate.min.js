/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.98
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
!function(t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).pako = {});
}(this, function(t) {
  "use strict";
  function e(t2) {
    let e2 = t2.length;
    for (; --e2 >= 0; )
      t2[e2] = 0;
  }
  const a = 256, n = 286, r = 30, i = 15, s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), _ = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), l = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), h = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = new Array(576);
  e(o);
  const d = new Array(60);
  e(d);
  const u = new Array(512);
  e(u);
  const f = new Array(256);
  e(f);
  const c = new Array(29);
  e(c);
  const p = new Array(r);
  function g(t2, e2, a2, n2, r2) {
    this.static_tree = t2, this.extra_bits = e2, this.extra_base = a2, this.elems = n2, this.max_length = r2, this.has_stree = t2 && t2.length;
  }
  let w, b, m;
  function v(t2, e2) {
    this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
  }
  e(p);
  const y = (t2) => t2 < 256 ? u[t2] : u[256 + (t2 >>> 7)], z = (t2, e2) => {
    t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
  }, k = (t2, e2, a2) => {
    t2.bi_valid > 16 - a2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, z(t2, t2.bi_buf), t2.bi_buf = e2 >> 16 - t2.bi_valid, t2.bi_valid += a2 - 16) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += a2);
  }, x = (t2, e2, a2) => {
    k(t2, a2[2 * e2], a2[2 * e2 + 1]);
  }, A = (t2, e2) => {
    let a2 = 0;
    do {
      a2 |= 1 & t2, t2 >>>= 1, a2 <<= 1;
    } while (--e2 > 0);
    return a2 >>> 1;
  }, E = (t2, e2, a2) => {
    const n2 = new Array(16);
    let r2, s2, _2 = 0;
    for (r2 = 1; r2 <= i; r2++)
      n2[r2] = _2 = _2 + a2[r2 - 1] << 1;
    for (s2 = 0; s2 <= e2; s2++) {
      let e3 = t2[2 * s2 + 1];
      0 !== e3 && (t2[2 * s2] = A(n2[e3]++, e3));
    }
  }, Z = (t2) => {
    let e2;
    for (e2 = 0; e2 < n; e2++)
      t2.dyn_ltree[2 * e2] = 0;
    for (e2 = 0; e2 < r; e2++)
      t2.dyn_dtree[2 * e2] = 0;
    for (e2 = 0; e2 < 19; e2++)
      t2.bl_tree[2 * e2] = 0;
    t2.dyn_ltree[512] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
  }, R = (t2) => {
    t2.bi_valid > 8 ? z(t2, t2.bi_buf) : t2.bi_valid > 0 && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
  }, U = (t2, e2, a2, n2) => {
    const r2 = 2 * e2, i2 = 2 * a2;
    return t2[r2] < t2[i2] || t2[r2] === t2[i2] && n2[e2] <= n2[a2];
  }, S = (t2, e2, a2) => {
    const n2 = t2.heap[a2];
    let r2 = a2 << 1;
    for (; r2 <= t2.heap_len && (r2 < t2.heap_len && U(e2, t2.heap[r2 + 1], t2.heap[r2], t2.depth) && r2++, !U(e2, n2, t2.heap[r2], t2.depth)); )
      t2.heap[a2] = t2.heap[r2], a2 = r2, r2 <<= 1;
    t2.heap[a2] = n2;
  }, T = (t2, e2, n2) => {
    let r2, i2, l2, h2, o2 = 0;
    if (0 !== t2.last_lit)
      do {
        r2 = t2.pending_buf[t2.d_buf + 2 * o2] << 8 | t2.pending_buf[t2.d_buf + 2 * o2 + 1], i2 = t2.pending_buf[t2.l_buf + o2], o2++, 0 === r2 ? x(t2, i2, e2) : (l2 = f[i2], x(t2, l2 + a + 1, e2), h2 = s[l2], 0 !== h2 && (i2 -= c[l2], k(t2, i2, h2)), r2--, l2 = y(r2), x(t2, l2, n2), h2 = _[l2], 0 !== h2 && (r2 -= p[l2], k(t2, r2, h2)));
      } while (o2 < t2.last_lit);
    x(t2, 256, e2);
  }, L = (t2, e2) => {
    const a2 = e2.dyn_tree, n2 = e2.stat_desc.static_tree, r2 = e2.stat_desc.has_stree, s2 = e2.stat_desc.elems;
    let _2, l2, h2, o2 = -1;
    for (t2.heap_len = 0, t2.heap_max = 573, _2 = 0; _2 < s2; _2++)
      0 !== a2[2 * _2] ? (t2.heap[++t2.heap_len] = o2 = _2, t2.depth[_2] = 0) : a2[2 * _2 + 1] = 0;
    for (; t2.heap_len < 2; )
      h2 = t2.heap[++t2.heap_len] = o2 < 2 ? ++o2 : 0, a2[2 * h2] = 1, t2.depth[h2] = 0, t2.opt_len--, r2 && (t2.static_len -= n2[2 * h2 + 1]);
    for (e2.max_code = o2, _2 = t2.heap_len >> 1; _2 >= 1; _2--)
      S(t2, a2, _2);
    h2 = s2;
    do {
      _2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], S(t2, a2, 1), l2 = t2.heap[1], t2.heap[--t2.heap_max] = _2, t2.heap[--t2.heap_max] = l2, a2[2 * h2] = a2[2 * _2] + a2[2 * l2], t2.depth[h2] = (t2.depth[_2] >= t2.depth[l2] ? t2.depth[_2] : t2.depth[l2]) + 1, a2[2 * _2 + 1] = a2[2 * l2 + 1] = h2, t2.heap[1] = h2++, S(t2, a2, 1);
    } while (t2.heap_len >= 2);
    t2.heap[--t2.heap_max] = t2.heap[1], ((t3, e3) => {
      const a3 = e3.dyn_tree, n3 = e3.max_code, r3 = e3.stat_desc.static_tree, s3 = e3.stat_desc.has_stree, _3 = e3.stat_desc.extra_bits, l3 = e3.stat_desc.extra_base, h3 = e3.stat_desc.max_length;
      let o3, d2, u2, f2, c2, p2, g2 = 0;
      for (f2 = 0; f2 <= i; f2++)
        t3.bl_count[f2] = 0;
      for (a3[2 * t3.heap[t3.heap_max] + 1] = 0, o3 = t3.heap_max + 1; o3 < 573; o3++)
        d2 = t3.heap[o3], f2 = a3[2 * a3[2 * d2 + 1] + 1] + 1, f2 > h3 && (f2 = h3, g2++), a3[2 * d2 + 1] = f2, d2 > n3 || (t3.bl_count[f2]++, c2 = 0, d2 >= l3 && (c2 = _3[d2 - l3]), p2 = a3[2 * d2], t3.opt_len += p2 * (f2 + c2), s3 && (t3.static_len += p2 * (r3[2 * d2 + 1] + c2)));
      if (0 !== g2) {
        do {
          for (f2 = h3 - 1; 0 === t3.bl_count[f2]; )
            f2--;
          t3.bl_count[f2]--, t3.bl_count[f2 + 1] += 2, t3.bl_count[h3]--, g2 -= 2;
        } while (g2 > 0);
        for (f2 = h3; 0 !== f2; f2--)
          for (d2 = t3.bl_count[f2]; 0 !== d2; )
            u2 = t3.heap[--o3], u2 > n3 || (a3[2 * u2 + 1] !== f2 && (t3.opt_len += (f2 - a3[2 * u2 + 1]) * a3[2 * u2], a3[2 * u2 + 1] = f2), d2--);
      }
    })(t2, e2), E(a2, o2, t2.bl_count);
  }, F = (t2, e2, a2) => {
    let n2, r2, i2 = -1, s2 = e2[1], _2 = 0, l2 = 7, h2 = 4;
    for (0 === s2 && (l2 = 138, h2 = 3), e2[2 * (a2 + 1) + 1] = 65535, n2 = 0; n2 <= a2; n2++)
      r2 = s2, s2 = e2[2 * (n2 + 1) + 1], ++_2 < l2 && r2 === s2 || (_2 < h2 ? t2.bl_tree[2 * r2] += _2 : 0 !== r2 ? (r2 !== i2 && t2.bl_tree[2 * r2]++, t2.bl_tree[32]++) : _2 <= 10 ? t2.bl_tree[34]++ : t2.bl_tree[36]++, _2 = 0, i2 = r2, 0 === s2 ? (l2 = 138, h2 = 3) : r2 === s2 ? (l2 = 6, h2 = 3) : (l2 = 7, h2 = 4));
  }, O = (t2, e2, a2) => {
    let n2, r2, i2 = -1, s2 = e2[1], _2 = 0, l2 = 7, h2 = 4;
    for (0 === s2 && (l2 = 138, h2 = 3), n2 = 0; n2 <= a2; n2++)
      if (r2 = s2, s2 = e2[2 * (n2 + 1) + 1], !(++_2 < l2 && r2 === s2)) {
        if (_2 < h2)
          do {
            x(t2, r2, t2.bl_tree);
          } while (0 != --_2);
        else
          0 !== r2 ? (r2 !== i2 && (x(t2, r2, t2.bl_tree), _2--), x(t2, 16, t2.bl_tree), k(t2, _2 - 3, 2)) : _2 <= 10 ? (x(t2, 17, t2.bl_tree), k(t2, _2 - 3, 3)) : (x(t2, 18, t2.bl_tree), k(t2, _2 - 11, 7));
        _2 = 0, i2 = r2, 0 === s2 ? (l2 = 138, h2 = 3) : r2 === s2 ? (l2 = 6, h2 = 3) : (l2 = 7, h2 = 4);
      }
  };
  let D = false;
  const N = (t2, e2, a2, n2) => {
    k(t2, 0 + (n2 ? 1 : 0), 3), ((t3, e3, a3, n3) => {
      R(t3), n3 && (z(t3, a3), z(t3, ~a3)), t3.pending_buf.set(t3.window.subarray(e3, e3 + a3), t3.pending), t3.pending += a3;
    })(t2, e2, a2, true);
  };
  var I = { _tr_init: (t2) => {
    D || ((() => {
      let t3, e2, a2, h2, v2;
      const y2 = new Array(16);
      for (a2 = 0, h2 = 0; h2 < 28; h2++)
        for (c[h2] = a2, t3 = 0; t3 < 1 << s[h2]; t3++)
          f[a2++] = h2;
      for (f[a2 - 1] = h2, v2 = 0, h2 = 0; h2 < 16; h2++)
        for (p[h2] = v2, t3 = 0; t3 < 1 << _[h2]; t3++)
          u[v2++] = h2;
      for (v2 >>= 7; h2 < r; h2++)
        for (p[h2] = v2 << 7, t3 = 0; t3 < 1 << _[h2] - 7; t3++)
          u[256 + v2++] = h2;
      for (e2 = 0; e2 <= i; e2++)
        y2[e2] = 0;
      for (t3 = 0; t3 <= 143; )
        o[2 * t3 + 1] = 8, t3++, y2[8]++;
      for (; t3 <= 255; )
        o[2 * t3 + 1] = 9, t3++, y2[9]++;
      for (; t3 <= 279; )
        o[2 * t3 + 1] = 7, t3++, y2[7]++;
      for (; t3 <= 287; )
        o[2 * t3 + 1] = 8, t3++, y2[8]++;
      for (E(o, 287, y2), t3 = 0; t3 < r; t3++)
        d[2 * t3 + 1] = 5, d[2 * t3] = A(t3, 5);
      w = new g(o, s, 257, n, i), b = new g(d, _, 0, r, i), m = new g(new Array(0), l, 0, 19, 7);
    })(), D = true), t2.l_desc = new v(t2.dyn_ltree, w), t2.d_desc = new v(t2.dyn_dtree, b), t2.bl_desc = new v(t2.bl_tree, m), t2.bi_buf = 0, t2.bi_valid = 0, Z(t2);
  }, _tr_stored_block: N, _tr_flush_block: (t2, e2, n2, r2) => {
    let i2, s2, _2 = 0;
    t2.level > 0 ? (2 === t2.strm.data_type && (t2.strm.data_type = ((t3) => {
      let e3, n3 = 4093624447;
      for (e3 = 0; e3 <= 31; e3++, n3 >>>= 1)
        if (1 & n3 && 0 !== t3.dyn_ltree[2 * e3])
          return 0;
      if (0 !== t3.dyn_ltree[18] || 0 !== t3.dyn_ltree[20] || 0 !== t3.dyn_ltree[26])
        return 1;
      for (e3 = 32; e3 < a; e3++)
        if (0 !== t3.dyn_ltree[2 * e3])
          return 1;
      return 0;
    })(t2)), L(t2, t2.l_desc), L(t2, t2.d_desc), _2 = ((t3) => {
      let e3;
      for (F(t3, t3.dyn_ltree, t3.l_desc.max_code), F(t3, t3.dyn_dtree, t3.d_desc.max_code), L(t3, t3.bl_desc), e3 = 18; e3 >= 3 && 0 === t3.bl_tree[2 * h[e3] + 1]; e3--)
        ;
      return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
    })(t2), i2 = t2.opt_len + 3 + 7 >>> 3, s2 = t2.static_len + 3 + 7 >>> 3, s2 <= i2 && (i2 = s2)) : i2 = s2 = n2 + 5, n2 + 4 <= i2 && -1 !== e2 ? N(t2, e2, n2, r2) : 4 === t2.strategy || s2 === i2 ? (k(t2, 2 + (r2 ? 1 : 0), 3), T(t2, o, d)) : (k(t2, 4 + (r2 ? 1 : 0), 3), ((t3, e3, a2, n3) => {
      let r3;
      for (k(t3, e3 - 257, 5), k(t3, a2 - 1, 5), k(t3, n3 - 4, 4), r3 = 0; r3 < n3; r3++)
        k(t3, t3.bl_tree[2 * h[r3] + 1], 3);
      O(t3, t3.dyn_ltree, e3 - 1), O(t3, t3.dyn_dtree, a2 - 1);
    })(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, _2 + 1), T(t2, t2.dyn_ltree, t2.dyn_dtree)), Z(t2), r2 && R(t2);
  }, _tr_tally: (t2, e2, n2) => (t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & n2, t2.last_lit++, 0 === e2 ? t2.dyn_ltree[2 * n2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (f[n2] + a + 1)]++, t2.dyn_dtree[2 * y(e2)]++), t2.last_lit === t2.lit_bufsize - 1), _tr_align: (t2) => {
    k(t2, 2, 3), x(t2, 256, o), ((t3) => {
      16 === t3.bi_valid ? (z(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : t3.bi_valid >= 8 && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
    })(t2);
  } };
  var C = (t2, e2, a2, n2) => {
    let r2 = 65535 & t2 | 0, i2 = t2 >>> 16 & 65535 | 0, s2 = 0;
    for (; 0 !== a2; ) {
      s2 = a2 > 2e3 ? 2e3 : a2, a2 -= s2;
      do {
        r2 = r2 + e2[n2++] | 0, i2 = i2 + r2 | 0;
      } while (--s2);
      r2 %= 65521, i2 %= 65521;
    }
    return r2 | i2 << 16 | 0;
  };
  const B = new Uint32Array((() => {
    let t2, e2 = [];
    for (var a2 = 0; a2 < 256; a2++) {
      t2 = a2;
      for (var n2 = 0; n2 < 8; n2++)
        t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
      e2[a2] = t2;
    }
    return e2;
  })());
  var H = (t2, e2, a2, n2) => {
    const r2 = B, i2 = n2 + a2;
    t2 ^= -1;
    for (let a3 = n2; a3 < i2; a3++)
      t2 = t2 >>> 8 ^ r2[255 & (t2 ^ e2[a3])];
    return -1 ^ t2;
  }, M = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, P = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  const { _tr_init: j, _tr_stored_block: K, _tr_flush_block: Y, _tr_tally: G, _tr_align: X } = I, { Z_NO_FLUSH: W, Z_PARTIAL_FLUSH: q, Z_FULL_FLUSH: J, Z_FINISH: Q, Z_BLOCK: V, Z_OK: $, Z_STREAM_END: tt, Z_STREAM_ERROR: et, Z_DATA_ERROR: at, Z_BUF_ERROR: nt, Z_DEFAULT_COMPRESSION: rt, Z_FILTERED: it, Z_HUFFMAN_ONLY: st, Z_RLE: _t, Z_FIXED: lt, Z_DEFAULT_STRATEGY: ht, Z_UNKNOWN: ot, Z_DEFLATED: dt } = P, ut = 258, ft = 262, ct = 103, pt = 113, gt = 666, wt = (t2, e2) => (t2.msg = M[e2], e2), bt = (t2) => (t2 << 1) - (t2 > 4 ? 9 : 0), mt = (t2) => {
    let e2 = t2.length;
    for (; --e2 >= 0; )
      t2[e2] = 0;
  };
  let vt = (t2, e2, a2) => (e2 << t2.hash_shift ^ a2) & t2.hash_mask;
  const yt = (t2) => {
    const e2 = t2.state;
    let a2 = e2.pending;
    a2 > t2.avail_out && (a2 = t2.avail_out), 0 !== a2 && (t2.output.set(e2.pending_buf.subarray(e2.pending_out, e2.pending_out + a2), t2.next_out), t2.next_out += a2, e2.pending_out += a2, t2.total_out += a2, t2.avail_out -= a2, e2.pending -= a2, 0 === e2.pending && (e2.pending_out = 0));
  }, zt = (t2, e2) => {
    Y(t2, t2.block_start >= 0 ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, yt(t2.strm);
  }, kt = (t2, e2) => {
    t2.pending_buf[t2.pending++] = e2;
  }, xt = (t2, e2) => {
    t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
  }, At = (t2, e2, a2, n2) => {
    let r2 = t2.avail_in;
    return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (t2.avail_in -= r2, e2.set(t2.input.subarray(t2.next_in, t2.next_in + r2), a2), 1 === t2.state.wrap ? t2.adler = C(t2.adler, e2, r2, a2) : 2 === t2.state.wrap && (t2.adler = H(t2.adler, e2, r2, a2)), t2.next_in += r2, t2.total_in += r2, r2);
  }, Et = (t2, e2) => {
    let a2, n2, r2 = t2.max_chain_length, i2 = t2.strstart, s2 = t2.prev_length, _2 = t2.nice_match;
    const l2 = t2.strstart > t2.w_size - ft ? t2.strstart - (t2.w_size - ft) : 0, h2 = t2.window, o2 = t2.w_mask, d2 = t2.prev, u2 = t2.strstart + ut;
    let f2 = h2[i2 + s2 - 1], c2 = h2[i2 + s2];
    t2.prev_length >= t2.good_match && (r2 >>= 2), _2 > t2.lookahead && (_2 = t2.lookahead);
    do {
      if (a2 = e2, h2[a2 + s2] === c2 && h2[a2 + s2 - 1] === f2 && h2[a2] === h2[i2] && h2[++a2] === h2[i2 + 1]) {
        i2 += 2, a2++;
        do {
        } while (h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && h2[++i2] === h2[++a2] && i2 < u2);
        if (n2 = ut - (u2 - i2), i2 = u2 - ut, n2 > s2) {
          if (t2.match_start = e2, s2 = n2, n2 >= _2)
            break;
          f2 = h2[i2 + s2 - 1], c2 = h2[i2 + s2];
        }
      }
    } while ((e2 = d2[e2 & o2]) > l2 && 0 != --r2);
    return s2 <= t2.lookahead ? s2 : t2.lookahead;
  }, Zt = (t2) => {
    const e2 = t2.w_size;
    let a2, n2, r2, i2, s2;
    do {
      if (i2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= e2 + (e2 - ft)) {
        t2.window.set(t2.window.subarray(e2, e2 + e2), 0), t2.match_start -= e2, t2.strstart -= e2, t2.block_start -= e2, n2 = t2.hash_size, a2 = n2;
        do {
          r2 = t2.head[--a2], t2.head[a2] = r2 >= e2 ? r2 - e2 : 0;
        } while (--n2);
        n2 = e2, a2 = n2;
        do {
          r2 = t2.prev[--a2], t2.prev[a2] = r2 >= e2 ? r2 - e2 : 0;
        } while (--n2);
        i2 += e2;
      }
      if (0 === t2.strm.avail_in)
        break;
      if (n2 = At(t2.strm, t2.window, t2.strstart + t2.lookahead, i2), t2.lookahead += n2, t2.lookahead + t2.insert >= 3)
        for (s2 = t2.strstart - t2.insert, t2.ins_h = t2.window[s2], t2.ins_h = vt(t2, t2.ins_h, t2.window[s2 + 1]); t2.insert && (t2.ins_h = vt(t2, t2.ins_h, t2.window[s2 + 3 - 1]), t2.prev[s2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = s2, s2++, t2.insert--, !(t2.lookahead + t2.insert < 3)); )
          ;
    } while (t2.lookahead < ft && 0 !== t2.strm.avail_in);
  }, Rt = (t2, e2) => {
    let a2, n2;
    for (; ; ) {
      if (t2.lookahead < ft) {
        if (Zt(t2), t2.lookahead < ft && e2 === W)
          return 1;
        if (0 === t2.lookahead)
          break;
      }
      if (a2 = 0, t2.lookahead >= 3 && (t2.ins_h = vt(t2, t2.ins_h, t2.window[t2.strstart + 3 - 1]), a2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 !== a2 && t2.strstart - a2 <= t2.w_size - ft && (t2.match_length = Et(t2, a2)), t2.match_length >= 3)
        if (n2 = G(t2, t2.strstart - t2.match_start, t2.match_length - 3), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= 3) {
          t2.match_length--;
          do {
            t2.strstart++, t2.ins_h = vt(t2, t2.ins_h, t2.window[t2.strstart + 3 - 1]), a2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart;
          } while (0 != --t2.match_length);
          t2.strstart++;
        } else
          t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = vt(t2, t2.ins_h, t2.window[t2.strstart + 1]);
      else
        n2 = G(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
      if (n2 && (zt(t2, false), 0 === t2.strm.avail_out))
        return 1;
    }
    return t2.insert = t2.strstart < 2 ? t2.strstart : 2, e2 === Q ? (zt(t2, true), 0 === t2.strm.avail_out ? 3 : 4) : t2.last_lit && (zt(t2, false), 0 === t2.strm.avail_out) ? 1 : 2;
  }, Ut = (t2, e2) => {
    let a2, n2, r2;
    for (; ; ) {
      if (t2.lookahead < ft) {
        if (Zt(t2), t2.lookahead < ft && e2 === W)
          return 1;
        if (0 === t2.lookahead)
          break;
      }
      if (a2 = 0, t2.lookahead >= 3 && (t2.ins_h = vt(t2, t2.ins_h, t2.window[t2.strstart + 3 - 1]), a2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = 2, 0 !== a2 && t2.prev_length < t2.max_lazy_match && t2.strstart - a2 <= t2.w_size - ft && (t2.match_length = Et(t2, a2), t2.match_length <= 5 && (t2.strategy === it || 3 === t2.match_length && t2.strstart - t2.match_start > 4096) && (t2.match_length = 2)), t2.prev_length >= 3 && t2.match_length <= t2.prev_length) {
        r2 = t2.strstart + t2.lookahead - 3, n2 = G(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - 3), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2;
        do {
          ++t2.strstart <= r2 && (t2.ins_h = vt(t2, t2.ins_h, t2.window[t2.strstart + 3 - 1]), a2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart);
        } while (0 != --t2.prev_length);
        if (t2.match_available = 0, t2.match_length = 2, t2.strstart++, n2 && (zt(t2, false), 0 === t2.strm.avail_out))
          return 1;
      } else if (t2.match_available) {
        if (n2 = G(t2, 0, t2.window[t2.strstart - 1]), n2 && zt(t2, false), t2.strstart++, t2.lookahead--, 0 === t2.strm.avail_out)
          return 1;
      } else
        t2.match_available = 1, t2.strstart++, t2.lookahead--;
    }
    return t2.match_available && (n2 = G(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < 2 ? t2.strstart : 2, e2 === Q ? (zt(t2, true), 0 === t2.strm.avail_out ? 3 : 4) : t2.last_lit && (zt(t2, false), 0 === t2.strm.avail_out) ? 1 : 2;
  };
  function St(t2, e2, a2, n2, r2) {
    this.good_length = t2, this.max_lazy = e2, this.nice_length = a2, this.max_chain = n2, this.func = r2;
  }
  const Tt = [new St(0, 0, 0, 0, (t2, e2) => {
    let a2 = 65535;
    for (a2 > t2.pending_buf_size - 5 && (a2 = t2.pending_buf_size - 5); ; ) {
      if (t2.lookahead <= 1) {
        if (Zt(t2), 0 === t2.lookahead && e2 === W)
          return 1;
        if (0 === t2.lookahead)
          break;
      }
      t2.strstart += t2.lookahead, t2.lookahead = 0;
      const n2 = t2.block_start + a2;
      if ((0 === t2.strstart || t2.strstart >= n2) && (t2.lookahead = t2.strstart - n2, t2.strstart = n2, zt(t2, false), 0 === t2.strm.avail_out))
        return 1;
      if (t2.strstart - t2.block_start >= t2.w_size - ft && (zt(t2, false), 0 === t2.strm.avail_out))
        return 1;
    }
    return t2.insert = 0, e2 === Q ? (zt(t2, true), 0 === t2.strm.avail_out ? 3 : 4) : (t2.strstart > t2.block_start && (zt(t2, false), t2.strm.avail_out), 1);
  }), new St(4, 4, 8, 4, Rt), new St(4, 5, 16, 8, Rt), new St(4, 6, 32, 32, Rt), new St(4, 4, 16, 16, Ut), new St(8, 16, 32, 32, Ut), new St(8, 16, 128, 128, Ut), new St(8, 32, 128, 256, Ut), new St(32, 128, 258, 1024, Ut), new St(32, 258, 258, 4096, Ut)];
  function Lt() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = dt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), mt(this.dyn_ltree), mt(this.dyn_dtree), mt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), mt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), mt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  const Ft = (t2) => {
    if (!t2 || !t2.state)
      return wt(t2, et);
    t2.total_in = t2.total_out = 0, t2.data_type = ot;
    const e2 = t2.state;
    return e2.pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? 42 : pt, t2.adler = 2 === e2.wrap ? 0 : 1, e2.last_flush = W, j(e2), $;
  }, Ot = (t2) => {
    const e2 = Ft(t2);
    var a2;
    return e2 === $ && ((a2 = t2.state).window_size = 2 * a2.w_size, mt(a2.head), a2.max_lazy_match = Tt[a2.level].max_lazy, a2.good_match = Tt[a2.level].good_length, a2.nice_match = Tt[a2.level].nice_length, a2.max_chain_length = Tt[a2.level].max_chain, a2.strstart = 0, a2.block_start = 0, a2.lookahead = 0, a2.insert = 0, a2.match_length = a2.prev_length = 2, a2.match_available = 0, a2.ins_h = 0), e2;
  }, Dt = (t2, e2, a2, n2, r2, i2) => {
    if (!t2)
      return et;
    let s2 = 1;
    if (e2 === rt && (e2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || a2 !== dt || n2 < 8 || n2 > 15 || e2 < 0 || e2 > 9 || i2 < 0 || i2 > lt)
      return wt(t2, et);
    8 === n2 && (n2 = 9);
    const _2 = new Lt();
    return t2.state = _2, _2.strm = t2, _2.wrap = s2, _2.gzhead = null, _2.w_bits = n2, _2.w_size = 1 << _2.w_bits, _2.w_mask = _2.w_size - 1, _2.hash_bits = r2 + 7, _2.hash_size = 1 << _2.hash_bits, _2.hash_mask = _2.hash_size - 1, _2.hash_shift = ~~((_2.hash_bits + 3 - 1) / 3), _2.window = new Uint8Array(2 * _2.w_size), _2.head = new Uint16Array(_2.hash_size), _2.prev = new Uint16Array(_2.w_size), _2.lit_bufsize = 1 << r2 + 6, _2.pending_buf_size = 4 * _2.lit_bufsize, _2.pending_buf = new Uint8Array(_2.pending_buf_size), _2.d_buf = 1 * _2.lit_bufsize, _2.l_buf = 3 * _2.lit_bufsize, _2.level = e2, _2.strategy = i2, _2.method = a2, Ot(t2);
  };
  var Nt = { deflateInit: (t2, e2) => Dt(t2, e2, dt, 15, 8, ht), deflateInit2: Dt, deflateReset: Ot, deflateResetKeep: Ft, deflateSetHeader: (t2, e2) => t2 && t2.state ? 2 !== t2.state.wrap ? et : (t2.state.gzhead = e2, $) : et, deflate: (t2, e2) => {
    let a2, n2;
    if (!t2 || !t2.state || e2 > V || e2 < 0)
      return t2 ? wt(t2, et) : et;
    const r2 = t2.state;
    if (!t2.output || !t2.input && 0 !== t2.avail_in || r2.status === gt && e2 !== Q)
      return wt(t2, 0 === t2.avail_out ? nt : et);
    r2.strm = t2;
    const i2 = r2.last_flush;
    if (r2.last_flush = e2, 42 === r2.status)
      if (2 === r2.wrap)
        t2.adler = 0, kt(r2, 31), kt(r2, 139), kt(r2, 8), r2.gzhead ? (kt(r2, (r2.gzhead.text ? 1 : 0) + (r2.gzhead.hcrc ? 2 : 0) + (r2.gzhead.extra ? 4 : 0) + (r2.gzhead.name ? 8 : 0) + (r2.gzhead.comment ? 16 : 0)), kt(r2, 255 & r2.gzhead.time), kt(r2, r2.gzhead.time >> 8 & 255), kt(r2, r2.gzhead.time >> 16 & 255), kt(r2, r2.gzhead.time >> 24 & 255), kt(r2, 9 === r2.level ? 2 : r2.strategy >= st || r2.level < 2 ? 4 : 0), kt(r2, 255 & r2.gzhead.os), r2.gzhead.extra && r2.gzhead.extra.length && (kt(r2, 255 & r2.gzhead.extra.length), kt(r2, r2.gzhead.extra.length >> 8 & 255)), r2.gzhead.hcrc && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending, 0)), r2.gzindex = 0, r2.status = 69) : (kt(r2, 0), kt(r2, 0), kt(r2, 0), kt(r2, 0), kt(r2, 0), kt(r2, 9 === r2.level ? 2 : r2.strategy >= st || r2.level < 2 ? 4 : 0), kt(r2, 3), r2.status = pt);
      else {
        let e3 = dt + (r2.w_bits - 8 << 4) << 8, a3 = -1;
        a3 = r2.strategy >= st || r2.level < 2 ? 0 : r2.level < 6 ? 1 : 6 === r2.level ? 2 : 3, e3 |= a3 << 6, 0 !== r2.strstart && (e3 |= 32), e3 += 31 - e3 % 31, r2.status = pt, xt(r2, e3), 0 !== r2.strstart && (xt(r2, t2.adler >>> 16), xt(r2, 65535 & t2.adler)), t2.adler = 1;
      }
    if (69 === r2.status)
      if (r2.gzhead.extra) {
        for (a2 = r2.pending; r2.gzindex < (65535 & r2.gzhead.extra.length) && (r2.pending !== r2.pending_buf_size || (r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), yt(t2), a2 = r2.pending, r2.pending !== r2.pending_buf_size)); )
          kt(r2, 255 & r2.gzhead.extra[r2.gzindex]), r2.gzindex++;
        r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), r2.gzindex === r2.gzhead.extra.length && (r2.gzindex = 0, r2.status = 73);
      } else
        r2.status = 73;
    if (73 === r2.status)
      if (r2.gzhead.name) {
        a2 = r2.pending;
        do {
          if (r2.pending === r2.pending_buf_size && (r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), yt(t2), a2 = r2.pending, r2.pending === r2.pending_buf_size)) {
            n2 = 1;
            break;
          }
          n2 = r2.gzindex < r2.gzhead.name.length ? 255 & r2.gzhead.name.charCodeAt(r2.gzindex++) : 0, kt(r2, n2);
        } while (0 !== n2);
        r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), 0 === n2 && (r2.gzindex = 0, r2.status = 91);
      } else
        r2.status = 91;
    if (91 === r2.status)
      if (r2.gzhead.comment) {
        a2 = r2.pending;
        do {
          if (r2.pending === r2.pending_buf_size && (r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), yt(t2), a2 = r2.pending, r2.pending === r2.pending_buf_size)) {
            n2 = 1;
            break;
          }
          n2 = r2.gzindex < r2.gzhead.comment.length ? 255 & r2.gzhead.comment.charCodeAt(r2.gzindex++) : 0, kt(r2, n2);
        } while (0 !== n2);
        r2.gzhead.hcrc && r2.pending > a2 && (t2.adler = H(t2.adler, r2.pending_buf, r2.pending - a2, a2)), 0 === n2 && (r2.status = ct);
      } else
        r2.status = ct;
    if (r2.status === ct && (r2.gzhead.hcrc ? (r2.pending + 2 > r2.pending_buf_size && yt(t2), r2.pending + 2 <= r2.pending_buf_size && (kt(r2, 255 & t2.adler), kt(r2, t2.adler >> 8 & 255), t2.adler = 0, r2.status = pt)) : r2.status = pt), 0 !== r2.pending) {
      if (yt(t2), 0 === t2.avail_out)
        return r2.last_flush = -1, $;
    } else if (0 === t2.avail_in && bt(e2) <= bt(i2) && e2 !== Q)
      return wt(t2, nt);
    if (r2.status === gt && 0 !== t2.avail_in)
      return wt(t2, nt);
    if (0 !== t2.avail_in || 0 !== r2.lookahead || e2 !== W && r2.status !== gt) {
      let a3 = r2.strategy === st ? ((t3, e3) => {
        let a4;
        for (; ; ) {
          if (0 === t3.lookahead && (Zt(t3), 0 === t3.lookahead)) {
            if (e3 === W)
              return 1;
            break;
          }
          if (t3.match_length = 0, a4 = G(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, a4 && (zt(t3, false), 0 === t3.strm.avail_out))
            return 1;
        }
        return t3.insert = 0, e3 === Q ? (zt(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.last_lit && (zt(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
      })(r2, e2) : r2.strategy === _t ? ((t3, e3) => {
        let a4, n3, r3, i3;
        const s2 = t3.window;
        for (; ; ) {
          if (t3.lookahead <= ut) {
            if (Zt(t3), t3.lookahead <= ut && e3 === W)
              return 1;
            if (0 === t3.lookahead)
              break;
          }
          if (t3.match_length = 0, t3.lookahead >= 3 && t3.strstart > 0 && (r3 = t3.strstart - 1, n3 = s2[r3], n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3])) {
            i3 = t3.strstart + ut;
            do {
            } while (n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && n3 === s2[++r3] && r3 < i3);
            t3.match_length = ut - (i3 - r3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
          }
          if (t3.match_length >= 3 ? (a4 = G(t3, 1, t3.match_length - 3), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (a4 = G(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), a4 && (zt(t3, false), 0 === t3.strm.avail_out))
            return 1;
        }
        return t3.insert = 0, e3 === Q ? (zt(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.last_lit && (zt(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
      })(r2, e2) : Tt[r2.level].func(r2, e2);
      if (3 !== a3 && 4 !== a3 || (r2.status = gt), 1 === a3 || 3 === a3)
        return 0 === t2.avail_out && (r2.last_flush = -1), $;
      if (2 === a3 && (e2 === q ? X(r2) : e2 !== V && (K(r2, 0, 0, false), e2 === J && (mt(r2.head), 0 === r2.lookahead && (r2.strstart = 0, r2.block_start = 0, r2.insert = 0))), yt(t2), 0 === t2.avail_out))
        return r2.last_flush = -1, $;
    }
    return e2 !== Q ? $ : r2.wrap <= 0 ? tt : (2 === r2.wrap ? (kt(r2, 255 & t2.adler), kt(r2, t2.adler >> 8 & 255), kt(r2, t2.adler >> 16 & 255), kt(r2, t2.adler >> 24 & 255), kt(r2, 255 & t2.total_in), kt(r2, t2.total_in >> 8 & 255), kt(r2, t2.total_in >> 16 & 255), kt(r2, t2.total_in >> 24 & 255)) : (xt(r2, t2.adler >>> 16), xt(r2, 65535 & t2.adler)), yt(t2), r2.wrap > 0 && (r2.wrap = -r2.wrap), 0 !== r2.pending ? $ : tt);
  }, deflateEnd: (t2) => {
    if (!t2 || !t2.state)
      return et;
    const e2 = t2.state.status;
    return 42 !== e2 && 69 !== e2 && 73 !== e2 && 91 !== e2 && e2 !== ct && e2 !== pt && e2 !== gt ? wt(t2, et) : (t2.state = null, e2 === pt ? wt(t2, at) : $);
  }, deflateSetDictionary: (t2, e2) => {
    let a2 = e2.length;
    if (!t2 || !t2.state)
      return et;
    const n2 = t2.state, r2 = n2.wrap;
    if (2 === r2 || 1 === r2 && 42 !== n2.status || n2.lookahead)
      return et;
    if (1 === r2 && (t2.adler = C(t2.adler, e2, a2, 0)), n2.wrap = 0, a2 >= n2.w_size) {
      0 === r2 && (mt(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
      let t3 = new Uint8Array(n2.w_size);
      t3.set(e2.subarray(a2 - n2.w_size, a2), 0), e2 = t3, a2 = n2.w_size;
    }
    const i2 = t2.avail_in, s2 = t2.next_in, _2 = t2.input;
    for (t2.avail_in = a2, t2.next_in = 0, t2.input = e2, Zt(n2); n2.lookahead >= 3; ) {
      let t3 = n2.strstart, e3 = n2.lookahead - 2;
      do {
        n2.ins_h = vt(n2, n2.ins_h, n2.window[t3 + 3 - 1]), n2.prev[t3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = t3, t3++;
      } while (--e3);
      n2.strstart = t3, n2.lookahead = 2, Zt(n2);
    }
    return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, t2.next_in = s2, t2.input = _2, t2.avail_in = i2, n2.wrap = r2, $;
  }, deflateInfo: "pako deflate (from Nodeca project)" };
  const It = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
  var Ct = function(t2) {
    const e2 = Array.prototype.slice.call(arguments, 1);
    for (; e2.length; ) {
      const a2 = e2.shift();
      if (a2) {
        if ("object" != typeof a2)
          throw new TypeError(a2 + "must be non-object");
        for (const e3 in a2)
          It(a2, e3) && (t2[e3] = a2[e3]);
      }
    }
    return t2;
  }, Bt = (t2) => {
    let e2 = 0;
    for (let a3 = 0, n2 = t2.length; a3 < n2; a3++)
      e2 += t2[a3].length;
    const a2 = new Uint8Array(e2);
    for (let e3 = 0, n2 = 0, r2 = t2.length; e3 < r2; e3++) {
      let r3 = t2[e3];
      a2.set(r3, n2), n2 += r3.length;
    }
    return a2;
  };
  let Ht = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (t2) {
    Ht = false;
  }
  const Mt = new Uint8Array(256);
  for (let t2 = 0; t2 < 256; t2++)
    Mt[t2] = t2 >= 252 ? 6 : t2 >= 248 ? 5 : t2 >= 240 ? 4 : t2 >= 224 ? 3 : t2 >= 192 ? 2 : 1;
  Mt[254] = Mt[254] = 1;
  var Pt = (t2) => {
    if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
      return new TextEncoder().encode(t2);
    let e2, a2, n2, r2, i2, s2 = t2.length, _2 = 0;
    for (r2 = 0; r2 < s2; r2++)
      a2 = t2.charCodeAt(r2), 55296 == (64512 & a2) && r2 + 1 < s2 && (n2 = t2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (a2 = 65536 + (a2 - 55296 << 10) + (n2 - 56320), r2++)), _2 += a2 < 128 ? 1 : a2 < 2048 ? 2 : a2 < 65536 ? 3 : 4;
    for (e2 = new Uint8Array(_2), i2 = 0, r2 = 0; i2 < _2; r2++)
      a2 = t2.charCodeAt(r2), 55296 == (64512 & a2) && r2 + 1 < s2 && (n2 = t2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (a2 = 65536 + (a2 - 55296 << 10) + (n2 - 56320), r2++)), a2 < 128 ? e2[i2++] = a2 : a2 < 2048 ? (e2[i2++] = 192 | a2 >>> 6, e2[i2++] = 128 | 63 & a2) : a2 < 65536 ? (e2[i2++] = 224 | a2 >>> 12, e2[i2++] = 128 | a2 >>> 6 & 63, e2[i2++] = 128 | 63 & a2) : (e2[i2++] = 240 | a2 >>> 18, e2[i2++] = 128 | a2 >>> 12 & 63, e2[i2++] = 128 | a2 >>> 6 & 63, e2[i2++] = 128 | 63 & a2);
    return e2;
  };
  var jt = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  };
  const Kt = Object.prototype.toString, { Z_NO_FLUSH: Yt, Z_SYNC_FLUSH: Gt, Z_FULL_FLUSH: Xt, Z_FINISH: Wt, Z_OK: qt, Z_STREAM_END: Jt, Z_DEFAULT_COMPRESSION: Qt, Z_DEFAULT_STRATEGY: Vt, Z_DEFLATED: $t } = P;
  function te(t2) {
    this.options = Ct({ level: Qt, method: $t, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Vt }, t2 || {});
    let e2 = this.options;
    e2.raw && e2.windowBits > 0 ? e2.windowBits = -e2.windowBits : e2.gzip && e2.windowBits > 0 && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new jt(), this.strm.avail_out = 0;
    let a2 = Nt.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
    if (a2 !== qt)
      throw new Error(M[a2]);
    if (e2.header && Nt.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
      let t3;
      if (t3 = "string" == typeof e2.dictionary ? Pt(e2.dictionary) : "[object ArrayBuffer]" === Kt.call(e2.dictionary) ? new Uint8Array(e2.dictionary) : e2.dictionary, a2 = Nt.deflateSetDictionary(this.strm, t3), a2 !== qt)
        throw new Error(M[a2]);
      this._dict_set = true;
    }
  }
  function ee(t2, e2) {
    const a2 = new te(e2);
    if (a2.push(t2, true), a2.err)
      throw a2.msg || M[a2.err];
    return a2.result;
  }
  te.prototype.push = function(t2, e2) {
    const a2 = this.strm, n2 = this.options.chunkSize;
    let r2, i2;
    if (this.ended)
      return false;
    for (i2 = e2 === ~~e2 ? e2 : true === e2 ? Wt : Yt, "string" == typeof t2 ? a2.input = Pt(t2) : "[object ArrayBuffer]" === Kt.call(t2) ? a2.input = new Uint8Array(t2) : a2.input = t2, a2.next_in = 0, a2.avail_in = a2.input.length; ; )
      if (0 === a2.avail_out && (a2.output = new Uint8Array(n2), a2.next_out = 0, a2.avail_out = n2), (i2 === Gt || i2 === Xt) && a2.avail_out <= 6)
        this.onData(a2.output.subarray(0, a2.next_out)), a2.avail_out = 0;
      else {
        if (r2 = Nt.deflate(a2, i2), r2 === Jt)
          return a2.next_out > 0 && this.onData(a2.output.subarray(0, a2.next_out)), r2 = Nt.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === qt;
        if (0 !== a2.avail_out) {
          if (i2 > 0 && a2.next_out > 0)
            this.onData(a2.output.subarray(0, a2.next_out)), a2.avail_out = 0;
          else if (0 === a2.avail_in)
            break;
        } else
          this.onData(a2.output);
      }
    return true;
  }, te.prototype.onData = function(t2) {
    this.chunks.push(t2);
  }, te.prototype.onEnd = function(t2) {
    t2 === qt && (this.result = Bt(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
  };
  var ae = te, ne = ee, re = function(t2, e2) {
    return (e2 = e2 || {}).raw = true, ee(t2, e2);
  }, ie = function(t2, e2) {
    return (e2 = e2 || {}).gzip = true, ee(t2, e2);
  }, se = P, _e = { Deflate: ae, deflate: ne, deflateRaw: re, gzip: ie, constants: se };
  t.Deflate = ae, t.constants = se, t.default = _e, t.deflate = ne, t.deflateRaw = re, t.gzip = ie, Object.defineProperty(t, "__esModule", { value: true });
});
