define(["./defaultValue-81eec7ed","./Matrix2-7fbd2afb","./ArcType-fc72c06c","./GeometryOffsetAttribute-8c5e10db","./BoundingRectangle-ea0566b7","./Transforms-969e35b7","./RuntimeError-8952249c","./ComponentDatatype-be80d12c","./EllipsoidGeodesic-1c1ae0bb","./EllipsoidTangentPlane-db930c09","./GeometryAttribute-6e58c1bc","./GeometryInstance-c4f24c7c","./GeometryPipeline-53aca64d","./IndexDatatype-a852edb7","./PolygonGeometryLibrary-2768b436","./PolygonPipeline-fd65423b","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-842a104c","./IntersectionTests-325bf999","./Plane-85eed013","./AttributeCompression-d533c8a1","./EncodedCartesian3-17187cc5","./arrayRemoveDuplicates-ea800094","./EllipsoidRhumbLine-c2325569","./GeometryAttributes-32b29525"],(function(e,t,o,r,i,n,a,s,l,c,u,p,y,d,m,g,h,f,b,_,P,C,x,w,T,I,A,v){"use strict";const E=new t.Cartographic,G=new t.Cartographic;function O(e,t,o,r){const i=r.cartesianToCartographic(e,E).height,n=r.cartesianToCartographic(t,G);n.height=i,r.cartographicToCartesian(n,t);const a=r.cartesianToCartographic(o,G);a.height=i-100,r.cartographicToCartesian(a,o)}const L=new i.BoundingRectangle,V=new t.Cartesian3,F=new t.Cartesian3,H=new t.Cartesian3,D=new t.Cartesian3,N=new t.Cartesian3,R=new t.Cartesian3;let M=new t.Cartesian3,S=new t.Cartesian3,B=new t.Cartesian3;const k=new t.Cartesian2,z=new t.Cartesian2,W=new t.Cartesian3,Y=new n.Quaternion,U=new t.Matrix3,j=new t.Matrix3;function Q(o){const i=o.vertexFormat,a=o.geometry,l=o.shadowVolume,c=a.attributes.position.values,p=e.defined(a.attributes.st)?a.attributes.st.values:void 0;let y=c.length;const d=o.wall,m=o.top||d,g=o.bottom||d;if(i.st||i.normal||i.tangent||i.bitangent||l){const r=o.boundingRectangle,h=o.tangentPlane,f=o.ellipsoid,b=o.stRotation,_=o.perPositionHeight,P=k;P.x=r.x,P.y=r.y;const C=i.st?new Float32Array(y/3*2):void 0;let x;i.normal&&(x=_&&m&&!d?a.attributes.normal.values:new Float32Array(y));const w=i.tangent?new Float32Array(y):void 0,T=i.bitangent?new Float32Array(y):void 0,I=l?new Float32Array(y):void 0;let A=0,v=0,E=F,G=H,L=D,Q=!0,q=U,K=j;if(0!==b){let e=n.Quaternion.fromAxisAngle(h._plane.normal,b,Y);q=t.Matrix3.fromQuaternion(e,q),e=n.Quaternion.fromAxisAngle(h._plane.normal,-b,Y),K=t.Matrix3.fromQuaternion(e,K)}else q=t.Matrix3.clone(t.Matrix3.IDENTITY,q),K=t.Matrix3.clone(t.Matrix3.IDENTITY,K);let Z=0,J=0;m&&g&&(Z=y/2,J=y/3,y/=2);for(let n=0;n<y;n+=3){const a=t.Cartesian3.fromArray(c,n,W);if(i.st&&!e.defined(p)){let e=t.Matrix3.multiplyByVector(q,a,V);e=f.scaleToGeodeticSurface(e,e);const o=h.projectPointOntoPlane(e,z);t.Cartesian2.subtract(o,P,o);const i=s.CesiumMath.clamp(o.x/r.width,0,1),n=s.CesiumMath.clamp(o.y/r.height,0,1);g&&(C[A+J]=i,C[A+1+J]=n),m&&(C[A]=i,C[A+1]=n),A+=2}if(i.normal||i.tangent||i.bitangent||l){const e=v+1,r=v+2;if(d){if(n+3<y){const e=t.Cartesian3.fromArray(c,n+3,N);if(Q){const o=t.Cartesian3.fromArray(c,n+y,R);_&&O(a,e,o,f),t.Cartesian3.subtract(e,a,e),t.Cartesian3.subtract(o,a,o),E=t.Cartesian3.normalize(t.Cartesian3.cross(o,e,E),E),Q=!1}t.Cartesian3.equalsEpsilon(e,a,s.CesiumMath.EPSILON10)&&(Q=!0)}(i.tangent||i.bitangent)&&(L=f.geodeticSurfaceNormal(a,L),i.tangent&&(G=t.Cartesian3.normalize(t.Cartesian3.cross(L,E,G),G)))}else E=f.geodeticSurfaceNormal(a,E),(i.tangent||i.bitangent)&&(_&&(M=t.Cartesian3.fromArray(x,v,M),S=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,M,S),S=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(K,S,S),S),i.bitangent&&(B=t.Cartesian3.normalize(t.Cartesian3.cross(M,S,B),B))),G=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,E,G),G=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(K,G,G),G),i.bitangent&&(L=t.Cartesian3.normalize(t.Cartesian3.cross(E,G,L),L)));i.normal&&(o.wall?(x[v+Z]=E.x,x[e+Z]=E.y,x[r+Z]=E.z):g&&(x[v+Z]=-E.x,x[e+Z]=-E.y,x[r+Z]=-E.z),(m&&!_||d)&&(x[v]=E.x,x[e]=E.y,x[r]=E.z)),l&&(d&&(E=f.geodeticSurfaceNormal(a,E)),I[v+Z]=-E.x,I[e+Z]=-E.y,I[r+Z]=-E.z),i.tangent&&(o.wall?(w[v+Z]=G.x,w[e+Z]=G.y,w[r+Z]=G.z):g&&(w[v+Z]=-G.x,w[e+Z]=-G.y,w[r+Z]=-G.z),m&&(_?(w[v]=S.x,w[e]=S.y,w[r]=S.z):(w[v]=G.x,w[e]=G.y,w[r]=G.z))),i.bitangent&&(g&&(T[v+Z]=L.x,T[e+Z]=L.y,T[r+Z]=L.z),m&&(_?(T[v]=B.x,T[e]=B.y,T[r]=B.z):(T[v]=L.x,T[e]=L.y,T[r]=L.z))),v+=3}}i.st&&!e.defined(p)&&(a.attributes.st=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:C})),i.normal&&(a.attributes.normal=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x})),i.tangent&&(a.attributes.tangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),i.bitangent&&(a.attributes.bitangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),l&&(a.attributes.extrudeDirection=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I}))}if(o.extrude&&e.defined(o.offsetAttribute)){const e=c.length/3;let t=new Uint8Array(e);if(o.offsetAttribute===r.GeometryOffsetAttribute.TOP)m&&g||d?t=r.arrayFill(t,1,0,e/2):m&&(t=r.arrayFill(t,1));else{const e=o.offsetAttribute===r.GeometryOffsetAttribute.NONE?0:1;t=r.arrayFill(t,e)}a.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return a}const q=new t.Cartographic,K=new t.Cartographic,Z={westOverIDL:0,eastOverIDL:0};let J=new l.EllipsoidGeodesic;function X(r,i,n,a,c){if(c=e.defaultValue(c,new t.Rectangle),!e.defined(r)||r.length<3)return c.west=0,c.north=0,c.south=0,c.east=0,c;if(n===o.ArcType.RHUMB)return t.Rectangle.fromCartesianArray(r,i,c);J.ellipsoid.equals(i)||(J=new l.EllipsoidGeodesic(void 0,void 0,i)),c.west=Number.POSITIVE_INFINITY,c.east=Number.NEGATIVE_INFINITY,c.south=Number.POSITIVE_INFINITY,c.north=Number.NEGATIVE_INFINITY,Z.westOverIDL=Number.POSITIVE_INFINITY,Z.eastOverIDL=Number.NEGATIVE_INFINITY;const u=1/s.CesiumMath.chordLength(a,i.maximumRadius),p=r.length;let y,d=i.cartesianToCartographic(r[0],K),m=q;for(let e=1;e<p;e++)y=m,m=d,d=i.cartesianToCartographic(r[e],y),J.setEndPoints(m,d),ee(J,u,c,Z);return y=m,m=d,d=i.cartesianToCartographic(r[0],y),J.setEndPoints(m,d),ee(J,u,c,Z),c.east-c.west>Z.eastOverIDL-Z.westOverIDL&&(c.west=Z.westOverIDL,c.east=Z.eastOverIDL,c.east>s.CesiumMath.PI&&(c.east=c.east-s.CesiumMath.TWO_PI),c.west>s.CesiumMath.PI&&(c.west=c.west-s.CesiumMath.TWO_PI)),c}const $=new t.Cartographic;function ee(e,t,o,r){const i=e.surfaceDistance,n=Math.ceil(i*t),a=n>0?i/(n-1):Number.POSITIVE_INFINITY;let l=0;for(let t=0;t<n;t++){const t=e.interpolateUsingSurfaceDistance(l,$);l+=a;const i=t.longitude,n=t.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const c=i>=0?i:i+s.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,c),r.eastOverIDL=Math.max(r.eastOverIDL,c)}}const te=[];function oe(t,o,r,i,n,a,s,l,u,y){const h={walls:[]};let f;if(s||l){const n=m.PolygonGeometryLibrary.createGeometryFromPositions(t,o,r,i,a,u,y),c=n.attributes.position.values,g=n.indices;let b,_;if(s&&l){const t=c.concat(c);b=t.length/3,_=d.IndexDatatype.createTypedArray(b,2*g.length),_.set(g);const o=g.length,i=b/2;for(f=0;f<o;f+=3){const e=_[f]+i,t=_[f+1]+i,r=_[f+2]+i;_[f+o]=r,_[f+1+o]=t,_[f+2+o]=e}if(n.attributes.position.values=t,a&&u.normal){const e=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(t.length),n.attributes.normal.values.set(e)}if(u.st&&e.defined(r)){const e=n.attributes.st.values;n.attributes.st.values=new Float32Array(2*b),n.attributes.st.values=e.concat(e)}n.indices=_}else if(l){for(b=c.length/3,_=d.IndexDatatype.createTypedArray(b,g.length),f=0;f<g.length;f+=3)_[f]=g[f+2],_[f+1]=g[f+1],_[f+2]=g[f];n.indices=_}h.topAndBottom=new p.GeometryInstance({geometry:n})}let b=n.outerRing,_=c.EllipsoidTangentPlane.fromPoints(b,t),P=_.projectPointsOntoPlane(b,te),C=g.PolygonPipeline.computeWindingOrder2D(P);C===g.WindingOrder.CLOCKWISE&&(b=b.slice().reverse());let x=m.PolygonGeometryLibrary.computeWallGeometry(b,r,t,i,a,y);h.walls.push(new p.GeometryInstance({geometry:x}));const w=n.holes;for(f=0;f<w.length;f++){let e=w[f];_=c.EllipsoidTangentPlane.fromPoints(e,t),P=_.projectPointsOntoPlane(e,te),C=g.PolygonPipeline.computeWindingOrder2D(P),C===g.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),x=m.PolygonGeometryLibrary.computeWallGeometry(e,r,t,i,a,y),h.walls.push(new p.GeometryInstance({geometry:x}))}return h}function re(r){const i=r.polygonHierarchy,n=e.defaultValue(r.vertexFormat,h.VertexFormat.DEFAULT),a=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84),l=e.defaultValue(r.granularity,s.CesiumMath.RADIANS_PER_DEGREE),c=e.defaultValue(r.stRotation,0),u=r.textureCoordinates,p=e.defaultValue(r.perPositionHeight,!1),y=p&&e.defined(r.extrudedHeight);let d=e.defaultValue(r.height,0),g=e.defaultValue(r.extrudedHeight,d);if(!y){const e=Math.max(d,g);g=Math.min(d,g),d=e}this._vertexFormat=h.VertexFormat.clone(n),this._ellipsoid=t.Ellipsoid.clone(a),this._granularity=l,this._stRotation=c,this._height=d,this._extrudedHeight=g,this._closeTop=e.defaultValue(r.closeTop,!0),this._closeBottom=e.defaultValue(r.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=p,this._perPositionHeightExtrude=y,this._shadowVolume=e.defaultValue(r.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=r.offsetAttribute,this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=m.PolygonGeometryLibrary.computeHierarchyPackedLength(i,t.Cartesian3)+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+(u?m.PolygonGeometryLibrary.computeHierarchyPackedLength(u,t.Cartesian2):1)+12}re.fromPositions=function(t){return new re({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},re.pack=function(o,r,i){return i=e.defaultValue(i,0),i=m.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,r,i,t.Cartesian3),t.Ellipsoid.pack(o._ellipsoid,r,i),i+=t.Ellipsoid.packedLength,h.VertexFormat.pack(o._vertexFormat,r,i),i+=h.VertexFormat.packedLength,r[i++]=o._height,r[i++]=o._extrudedHeight,r[i++]=o._granularity,r[i++]=o._stRotation,r[i++]=o._perPositionHeightExtrude?1:0,r[i++]=o._perPositionHeight?1:0,r[i++]=o._closeTop?1:0,r[i++]=o._closeBottom?1:0,r[i++]=o._shadowVolume?1:0,r[i++]=e.defaultValue(o._offsetAttribute,-1),r[i++]=o._arcType,e.defined(o._textureCoordinates)?i=m.PolygonGeometryLibrary.packPolygonHierarchy(o._textureCoordinates,r,i,t.Cartesian2):r[i++]=-1,r[i++]=o.packedLength,r};const ie=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),ne=new h.VertexFormat,ae={polygonHierarchy:{}};return re.unpack=function(o,r,i){r=e.defaultValue(r,0);const n=m.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,t.Cartesian3);r=n.startingIndex,delete n.startingIndex;const a=t.Ellipsoid.unpack(o,r,ie);r+=t.Ellipsoid.packedLength;const s=h.VertexFormat.unpack(o,r,ne);r+=h.VertexFormat.packedLength;const l=o[r++],c=o[r++],u=o[r++],p=o[r++],y=1===o[r++],d=1===o[r++],g=1===o[r++],f=1===o[r++],b=1===o[r++],_=o[r++],P=o[r++],C=-1===o[r]?void 0:m.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,t.Cartesian2);e.defined(C)?(r=C.startingIndex,delete C.startingIndex):r++;const x=o[r++];return e.defined(i)||(i=new re(ae)),i._polygonHierarchy=n,i._ellipsoid=t.Ellipsoid.clone(a,i._ellipsoid),i._vertexFormat=h.VertexFormat.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=c,i._granularity=u,i._stRotation=p,i._perPositionHeightExtrude=y,i._perPositionHeight=d,i._closeTop=g,i._closeBottom=f,i._shadowVolume=b,i._offsetAttribute=-1===_?void 0:_,i._arcType=P,i._textureCoordinates=C,i.packedLength=x,i},re.computeRectangle=function(r,i){const n=e.defaultValue(r.granularity,s.CesiumMath.RADIANS_PER_DEGREE),a=e.defaultValue(r.arcType,o.ArcType.GEODESIC),l=r.polygonHierarchy,c=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84);return X(l.positions,c,a,n,i)},re.createGeometry=function(t){const o=t._vertexFormat,i=t._ellipsoid,a=t._granularity,l=t._stRotation,h=t._polygonHierarchy,f=t._perPositionHeight,b=t._closeTop,_=t._closeBottom,P=t._arcType,C=t._textureCoordinates,x=e.defined(C);let w=h.positions;if(w.length<3)return;const T=c.EllipsoidTangentPlane.fromPoints(w,i),I=m.PolygonGeometryLibrary.polygonsFromHierarchy(h,x,T.projectPointsOntoPlane.bind(T),!f,i),A=I.hierarchy,v=I.polygons,E=x?m.PolygonGeometryLibrary.polygonsFromHierarchy(C,!0,(function(e){return e}),!1).polygons:void 0;if(0===A.length)return;w=A[0].outerRing;const G=m.PolygonGeometryLibrary.computeBoundingRectangle(T.plane.normal,T.projectPointOntoPlane.bind(T),w,l,L),O=[],V=t._height,F=t._extrudedHeight,H={perPositionHeight:f,vertexFormat:o,geometry:void 0,tangentPlane:T,boundingRectangle:G,ellipsoid:i,stRotation:l,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:P};let D;if(t._perPositionHeightExtrude||!s.CesiumMath.equalsEpsilon(V,F,0,s.CesiumMath.EPSILON2))for(H.extrude=!0,H.top=b,H.bottom=_,H.shadowVolume=t._shadowVolume,H.offsetAttribute=t._offsetAttribute,D=0;D<v.length;D++){const e=oe(i,v[D],x?E[D]:void 0,a,A[D],f,b,_,o,P);let t;b&&_?(t=e.topAndBottom,H.geometry=m.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,V,F,i,f)):b?(t=e.topAndBottom,t.geometry.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,V,i,!f),H.geometry=t.geometry):_&&(t=e.topAndBottom,t.geometry.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,F,i,!0),H.geometry=t.geometry),(b||_)&&(H.wall=!1,t.geometry=Q(H),O.push(t));const r=e.walls;H.wall=!0;for(let e=0;e<r.length;e++){const t=r[e];H.geometry=m.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,V,F,i,f),t.geometry=Q(H),O.push(t)}}else for(D=0;D<v.length;D++){const n=new p.GeometryInstance({geometry:m.PolygonGeometryLibrary.createGeometryFromPositions(i,v[D],x?E[D]:void 0,a,f,o,P)});if(n.geometry.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(n.geometry.attributes.position.values,V,i,!f),H.geometry=n.geometry,n.geometry=Q(H),e.defined(t._offsetAttribute)){const e=n.geometry.attributes.position.values.length,o=new Uint8Array(e/3),i=t._offsetAttribute===r.GeometryOffsetAttribute.NONE?0:1;r.arrayFill(o,i),n.geometry.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}O.push(n)}const N=y.GeometryPipeline.combineInstances(O)[0];N.attributes.position.values=new Float64Array(N.attributes.position.values),N.indices=d.IndexDatatype.createTypedArray(N.attributes.position.values.length/3,N.indices);const R=N.attributes,M=n.BoundingSphere.fromVertices(R.position.values);return o.position||delete R.position,new u.Geometry({attributes:R,indices:N.indices,primitiveType:N.primitiveType,boundingSphere:M,offsetAttribute:t._offsetAttribute})},re.createShadowVolume=function(e,t,o){const r=e._granularity,i=e._ellipsoid,n=t(r,i),a=o(r,i);return new re({polygonHierarchy:e._polygonHierarchy,ellipsoid:i,stRotation:e._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:h.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(re.prototype,{rectangle:{get:function(){if(!e.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=X(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return e.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const o=e._ellipsoid,r=e._polygonHierarchy.positions,i=e.rectangle;return u.Geometry._textureCoordinateRotationPoints(r,t,o,i)}(this)),this._textureCoordinateRotationPoints}}}),function(o,r){return e.defined(r)&&(o=re.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),re.createGeometry(o)}}));
