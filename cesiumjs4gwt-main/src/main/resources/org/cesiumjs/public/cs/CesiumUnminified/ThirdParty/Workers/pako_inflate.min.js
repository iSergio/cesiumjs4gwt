/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.98
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
!function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).pako = {});
}(this, function(e) {
  "use strict";
  var t = (e2, t2, i2, n2) => {
    let a2 = 65535 & e2 | 0, r2 = e2 >>> 16 & 65535 | 0, o2 = 0;
    for (; 0 !== i2; ) {
      o2 = i2 > 2e3 ? 2e3 : i2, i2 -= o2;
      do {
        a2 = a2 + t2[n2++] | 0, r2 = r2 + a2 | 0;
      } while (--o2);
      a2 %= 65521, r2 %= 65521;
    }
    return a2 | r2 << 16 | 0;
  };
  const i = new Uint32Array((() => {
    let e2, t2 = [];
    for (var i2 = 0; i2 < 256; i2++) {
      e2 = i2;
      for (var n2 = 0; n2 < 8; n2++)
        e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
      t2[i2] = e2;
    }
    return t2;
  })());
  var n = (e2, t2, n2, a2) => {
    const r2 = i, o2 = a2 + n2;
    e2 ^= -1;
    for (let i2 = a2; i2 < o2; i2++)
      e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t2[i2])];
    return -1 ^ e2;
  };
  var a = function(e2, t2) {
    let i2, n2, a2, r2, o2, s2, l2, d2, f2, c2, h2, u2, w2, b2, k2, m2, _2, g2, p2, v2, x2, y2, E2, R2;
    const A2 = e2.state;
    i2 = e2.next_in, E2 = e2.input, n2 = i2 + (e2.avail_in - 5), a2 = e2.next_out, R2 = e2.output, r2 = a2 - (t2 - e2.avail_out), o2 = a2 + (e2.avail_out - 257), s2 = A2.dmax, l2 = A2.wsize, d2 = A2.whave, f2 = A2.wnext, c2 = A2.window, h2 = A2.hold, u2 = A2.bits, w2 = A2.lencode, b2 = A2.distcode, k2 = (1 << A2.lenbits) - 1, m2 = (1 << A2.distbits) - 1;
    e:
      do {
        u2 < 15 && (h2 += E2[i2++] << u2, u2 += 8, h2 += E2[i2++] << u2, u2 += 8), _2 = w2[h2 & k2];
        t:
          for (; ; ) {
            if (g2 = _2 >>> 24, h2 >>>= g2, u2 -= g2, g2 = _2 >>> 16 & 255, 0 === g2)
              R2[a2++] = 65535 & _2;
            else {
              if (!(16 & g2)) {
                if (0 == (64 & g2)) {
                  _2 = w2[(65535 & _2) + (h2 & (1 << g2) - 1)];
                  continue t;
                }
                if (32 & g2) {
                  A2.mode = 12;
                  break e;
                }
                e2.msg = "invalid literal/length code", A2.mode = 30;
                break e;
              }
              p2 = 65535 & _2, g2 &= 15, g2 && (u2 < g2 && (h2 += E2[i2++] << u2, u2 += 8), p2 += h2 & (1 << g2) - 1, h2 >>>= g2, u2 -= g2), u2 < 15 && (h2 += E2[i2++] << u2, u2 += 8, h2 += E2[i2++] << u2, u2 += 8), _2 = b2[h2 & m2];
              i:
                for (; ; ) {
                  if (g2 = _2 >>> 24, h2 >>>= g2, u2 -= g2, g2 = _2 >>> 16 & 255, !(16 & g2)) {
                    if (0 == (64 & g2)) {
                      _2 = b2[(65535 & _2) + (h2 & (1 << g2) - 1)];
                      continue i;
                    }
                    e2.msg = "invalid distance code", A2.mode = 30;
                    break e;
                  }
                  if (v2 = 65535 & _2, g2 &= 15, u2 < g2 && (h2 += E2[i2++] << u2, u2 += 8, u2 < g2 && (h2 += E2[i2++] << u2, u2 += 8)), v2 += h2 & (1 << g2) - 1, v2 > s2) {
                    e2.msg = "invalid distance too far back", A2.mode = 30;
                    break e;
                  }
                  if (h2 >>>= g2, u2 -= g2, g2 = a2 - r2, v2 > g2) {
                    if (g2 = v2 - g2, g2 > d2 && A2.sane) {
                      e2.msg = "invalid distance too far back", A2.mode = 30;
                      break e;
                    }
                    if (x2 = 0, y2 = c2, 0 === f2) {
                      if (x2 += l2 - g2, g2 < p2) {
                        p2 -= g2;
                        do {
                          R2[a2++] = c2[x2++];
                        } while (--g2);
                        x2 = a2 - v2, y2 = R2;
                      }
                    } else if (f2 < g2) {
                      if (x2 += l2 + f2 - g2, g2 -= f2, g2 < p2) {
                        p2 -= g2;
                        do {
                          R2[a2++] = c2[x2++];
                        } while (--g2);
                        if (x2 = 0, f2 < p2) {
                          g2 = f2, p2 -= g2;
                          do {
                            R2[a2++] = c2[x2++];
                          } while (--g2);
                          x2 = a2 - v2, y2 = R2;
                        }
                      }
                    } else if (x2 += f2 - g2, g2 < p2) {
                      p2 -= g2;
                      do {
                        R2[a2++] = c2[x2++];
                      } while (--g2);
                      x2 = a2 - v2, y2 = R2;
                    }
                    for (; p2 > 2; )
                      R2[a2++] = y2[x2++], R2[a2++] = y2[x2++], R2[a2++] = y2[x2++], p2 -= 3;
                    p2 && (R2[a2++] = y2[x2++], p2 > 1 && (R2[a2++] = y2[x2++]));
                  } else {
                    x2 = a2 - v2;
                    do {
                      R2[a2++] = R2[x2++], R2[a2++] = R2[x2++], R2[a2++] = R2[x2++], p2 -= 3;
                    } while (p2 > 2);
                    p2 && (R2[a2++] = R2[x2++], p2 > 1 && (R2[a2++] = R2[x2++]));
                  }
                  break;
                }
            }
            break;
          }
      } while (i2 < n2 && a2 < o2);
    p2 = u2 >> 3, i2 -= p2, u2 -= p2 << 3, h2 &= (1 << u2) - 1, e2.next_in = i2, e2.next_out = a2, e2.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), e2.avail_out = a2 < o2 ? o2 - a2 + 257 : 257 - (a2 - o2), A2.hold = h2, A2.bits = u2;
  };
  const r = 15, o = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), s = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), l = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), d = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
  var f = (e2, t2, i2, n2, a2, f2, c2, h2) => {
    const u2 = h2.bits;
    let w2, b2, k2, m2, _2, g2, p2 = 0, v2 = 0, x2 = 0, y2 = 0, E2 = 0, R2 = 0, A2 = 0, Z2 = 0, S2 = 0, T2 = 0, O2 = null, U2 = 0;
    const D2 = new Uint16Array(16), I2 = new Uint16Array(16);
    let B2, N2, C2, z2 = null, F2 = 0;
    for (p2 = 0; p2 <= r; p2++)
      D2[p2] = 0;
    for (v2 = 0; v2 < n2; v2++)
      D2[t2[i2 + v2]]++;
    for (E2 = u2, y2 = r; y2 >= 1 && 0 === D2[y2]; y2--)
      ;
    if (E2 > y2 && (E2 = y2), 0 === y2)
      return a2[f2++] = 20971520, a2[f2++] = 20971520, h2.bits = 1, 0;
    for (x2 = 1; x2 < y2 && 0 === D2[x2]; x2++)
      ;
    for (E2 < x2 && (E2 = x2), Z2 = 1, p2 = 1; p2 <= r; p2++)
      if (Z2 <<= 1, Z2 -= D2[p2], Z2 < 0)
        return -1;
    if (Z2 > 0 && (0 === e2 || 1 !== y2))
      return -1;
    for (I2[1] = 0, p2 = 1; p2 < r; p2++)
      I2[p2 + 1] = I2[p2] + D2[p2];
    for (v2 = 0; v2 < n2; v2++)
      0 !== t2[i2 + v2] && (c2[I2[t2[i2 + v2]]++] = v2);
    if (0 === e2 ? (O2 = z2 = c2, g2 = 19) : 1 === e2 ? (O2 = o, U2 -= 257, z2 = s, F2 -= 257, g2 = 256) : (O2 = l, z2 = d, g2 = -1), T2 = 0, v2 = 0, p2 = x2, _2 = f2, R2 = E2, A2 = 0, k2 = -1, S2 = 1 << E2, m2 = S2 - 1, 1 === e2 && S2 > 852 || 2 === e2 && S2 > 592)
      return 1;
    for (; ; ) {
      B2 = p2 - A2, c2[v2] < g2 ? (N2 = 0, C2 = c2[v2]) : c2[v2] > g2 ? (N2 = z2[F2 + c2[v2]], C2 = O2[U2 + c2[v2]]) : (N2 = 96, C2 = 0), w2 = 1 << p2 - A2, b2 = 1 << R2, x2 = b2;
      do {
        b2 -= w2, a2[_2 + (T2 >> A2) + b2] = B2 << 24 | N2 << 16 | C2 | 0;
      } while (0 !== b2);
      for (w2 = 1 << p2 - 1; T2 & w2; )
        w2 >>= 1;
      if (0 !== w2 ? (T2 &= w2 - 1, T2 += w2) : T2 = 0, v2++, 0 == --D2[p2]) {
        if (p2 === y2)
          break;
        p2 = t2[i2 + c2[v2]];
      }
      if (p2 > E2 && (T2 & m2) !== k2) {
        for (0 === A2 && (A2 = E2), _2 += x2, R2 = p2 - A2, Z2 = 1 << R2; R2 + A2 < y2 && (Z2 -= D2[R2 + A2], !(Z2 <= 0)); )
          R2++, Z2 <<= 1;
        if (S2 += 1 << R2, 1 === e2 && S2 > 852 || 2 === e2 && S2 > 592)
          return 1;
        k2 = T2 & m2, a2[k2] = E2 << 24 | R2 << 16 | _2 - f2 | 0;
      }
    }
    return 0 !== T2 && (a2[_2 + T2] = p2 - A2 << 24 | 64 << 16 | 0), h2.bits = E2, 0;
  }, c = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  const { Z_FINISH: h, Z_BLOCK: u, Z_TREES: w, Z_OK: b, Z_STREAM_END: k, Z_NEED_DICT: m, Z_STREAM_ERROR: _, Z_DATA_ERROR: g, Z_MEM_ERROR: p, Z_BUF_ERROR: v, Z_DEFLATED: x } = c, y = 12, E = 30, R = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
  function A() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  const Z = (e2) => {
    if (!e2 || !e2.state)
      return _;
    const t2 = e2.state;
    return e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = 1, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, b;
  }, S = (e2) => {
    if (!e2 || !e2.state)
      return _;
    const t2 = e2.state;
    return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, Z(e2);
  }, T = (e2, t2) => {
    let i2;
    if (!e2 || !e2.state)
      return _;
    const n2 = e2.state;
    return t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? _ : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i2, n2.wbits = t2, S(e2));
  }, O = (e2, t2) => {
    if (!e2)
      return _;
    const i2 = new A();
    e2.state = i2, i2.window = null;
    const n2 = T(e2, t2);
    return n2 !== b && (e2.state = null), n2;
  };
  let U, D, I = true;
  const B = (e2) => {
    if (I) {
      U = new Int32Array(512), D = new Int32Array(32);
      let t2 = 0;
      for (; t2 < 144; )
        e2.lens[t2++] = 8;
      for (; t2 < 256; )
        e2.lens[t2++] = 9;
      for (; t2 < 280; )
        e2.lens[t2++] = 7;
      for (; t2 < 288; )
        e2.lens[t2++] = 8;
      for (f(1, e2.lens, 0, 288, U, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
        e2.lens[t2++] = 5;
      f(2, e2.lens, 0, 32, D, 0, e2.work, { bits: 5 }), I = false;
    }
    e2.lencode = U, e2.lenbits = 9, e2.distcode = D, e2.distbits = 5;
  }, N = (e2, t2, i2, n2) => {
    let a2;
    const r2 = e2.state;
    return null === r2.window && (r2.wsize = 1 << r2.wbits, r2.wnext = 0, r2.whave = 0, r2.window = new Uint8Array(r2.wsize)), n2 >= r2.wsize ? (r2.window.set(t2.subarray(i2 - r2.wsize, i2), 0), r2.wnext = 0, r2.whave = r2.wsize) : (a2 = r2.wsize - r2.wnext, a2 > n2 && (a2 = n2), r2.window.set(t2.subarray(i2 - n2, i2 - n2 + a2), r2.wnext), (n2 -= a2) ? (r2.window.set(t2.subarray(i2 - n2, i2), 0), r2.wnext = n2, r2.whave = r2.wsize) : (r2.wnext += a2, r2.wnext === r2.wsize && (r2.wnext = 0), r2.whave < r2.wsize && (r2.whave += a2))), 0;
  };
  var C = { inflateReset: S, inflateReset2: T, inflateResetKeep: Z, inflateInit: (e2) => O(e2, 15), inflateInit2: O, inflate: (e2, i2) => {
    let r2, o2, s2, l2, d2, c2, A2, Z2, S2, T2, O2, U2, D2, I2, C2, z2, F2, L2, M2, H2, j2, K2, P2 = 0;
    const Y2 = new Uint8Array(4);
    let G2, X2;
    const W2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
      return _;
    r2 = e2.state, r2.mode === y && (r2.mode = 13), d2 = e2.next_out, s2 = e2.output, A2 = e2.avail_out, l2 = e2.next_in, o2 = e2.input, c2 = e2.avail_in, Z2 = r2.hold, S2 = r2.bits, T2 = c2, O2 = A2, K2 = b;
    e:
      for (; ; )
        switch (r2.mode) {
          case 1:
            if (0 === r2.wrap) {
              r2.mode = 13;
              break;
            }
            for (; S2 < 16; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if (2 & r2.wrap && 35615 === Z2) {
              r2.check = 0, Y2[0] = 255 & Z2, Y2[1] = Z2 >>> 8 & 255, r2.check = n(r2.check, Y2, 2, 0), Z2 = 0, S2 = 0, r2.mode = 2;
              break;
            }
            if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & Z2) << 8) + (Z2 >> 8)) % 31) {
              e2.msg = "incorrect header check", r2.mode = E;
              break;
            }
            if ((15 & Z2) !== x) {
              e2.msg = "unknown compression method", r2.mode = E;
              break;
            }
            if (Z2 >>>= 4, S2 -= 4, j2 = 8 + (15 & Z2), 0 === r2.wbits)
              r2.wbits = j2;
            else if (j2 > r2.wbits) {
              e2.msg = "invalid window size", r2.mode = E;
              break;
            }
            r2.dmax = 1 << r2.wbits, e2.adler = r2.check = 1, r2.mode = 512 & Z2 ? 10 : y, Z2 = 0, S2 = 0;
            break;
          case 2:
            for (; S2 < 16; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if (r2.flags = Z2, (255 & r2.flags) !== x) {
              e2.msg = "unknown compression method", r2.mode = E;
              break;
            }
            if (57344 & r2.flags) {
              e2.msg = "unknown header flags set", r2.mode = E;
              break;
            }
            r2.head && (r2.head.text = Z2 >> 8 & 1), 512 & r2.flags && (Y2[0] = 255 & Z2, Y2[1] = Z2 >>> 8 & 255, r2.check = n(r2.check, Y2, 2, 0)), Z2 = 0, S2 = 0, r2.mode = 3;
          case 3:
            for (; S2 < 32; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            r2.head && (r2.head.time = Z2), 512 & r2.flags && (Y2[0] = 255 & Z2, Y2[1] = Z2 >>> 8 & 255, Y2[2] = Z2 >>> 16 & 255, Y2[3] = Z2 >>> 24 & 255, r2.check = n(r2.check, Y2, 4, 0)), Z2 = 0, S2 = 0, r2.mode = 4;
          case 4:
            for (; S2 < 16; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            r2.head && (r2.head.xflags = 255 & Z2, r2.head.os = Z2 >> 8), 512 & r2.flags && (Y2[0] = 255 & Z2, Y2[1] = Z2 >>> 8 & 255, r2.check = n(r2.check, Y2, 2, 0)), Z2 = 0, S2 = 0, r2.mode = 5;
          case 5:
            if (1024 & r2.flags) {
              for (; S2 < 16; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              r2.length = Z2, r2.head && (r2.head.extra_len = Z2), 512 & r2.flags && (Y2[0] = 255 & Z2, Y2[1] = Z2 >>> 8 & 255, r2.check = n(r2.check, Y2, 2, 0)), Z2 = 0, S2 = 0;
            } else
              r2.head && (r2.head.extra = null);
            r2.mode = 6;
          case 6:
            if (1024 & r2.flags && (U2 = r2.length, U2 > c2 && (U2 = c2), U2 && (r2.head && (j2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Uint8Array(r2.head.extra_len)), r2.head.extra.set(o2.subarray(l2, l2 + U2), j2)), 512 & r2.flags && (r2.check = n(r2.check, o2, U2, l2)), c2 -= U2, l2 += U2, r2.length -= U2), r2.length))
              break e;
            r2.length = 0, r2.mode = 7;
          case 7:
            if (2048 & r2.flags) {
              if (0 === c2)
                break e;
              U2 = 0;
              do {
                j2 = o2[l2 + U2++], r2.head && j2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(j2));
              } while (j2 && U2 < c2);
              if (512 & r2.flags && (r2.check = n(r2.check, o2, U2, l2)), c2 -= U2, l2 += U2, j2)
                break e;
            } else
              r2.head && (r2.head.name = null);
            r2.length = 0, r2.mode = 8;
          case 8:
            if (4096 & r2.flags) {
              if (0 === c2)
                break e;
              U2 = 0;
              do {
                j2 = o2[l2 + U2++], r2.head && j2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(j2));
              } while (j2 && U2 < c2);
              if (512 & r2.flags && (r2.check = n(r2.check, o2, U2, l2)), c2 -= U2, l2 += U2, j2)
                break e;
            } else
              r2.head && (r2.head.comment = null);
            r2.mode = 9;
          case 9:
            if (512 & r2.flags) {
              for (; S2 < 16; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              if (Z2 !== (65535 & r2.check)) {
                e2.msg = "header crc mismatch", r2.mode = E;
                break;
              }
              Z2 = 0, S2 = 0;
            }
            r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = y;
            break;
          case 10:
            for (; S2 < 32; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            e2.adler = r2.check = R(Z2), Z2 = 0, S2 = 0, r2.mode = 11;
          case 11:
            if (0 === r2.havedict)
              return e2.next_out = d2, e2.avail_out = A2, e2.next_in = l2, e2.avail_in = c2, r2.hold = Z2, r2.bits = S2, m;
            e2.adler = r2.check = 1, r2.mode = y;
          case y:
            if (i2 === u || i2 === w)
              break e;
          case 13:
            if (r2.last) {
              Z2 >>>= 7 & S2, S2 -= 7 & S2, r2.mode = 27;
              break;
            }
            for (; S2 < 3; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            switch (r2.last = 1 & Z2, Z2 >>>= 1, S2 -= 1, 3 & Z2) {
              case 0:
                r2.mode = 14;
                break;
              case 1:
                if (B(r2), r2.mode = 20, i2 === w) {
                  Z2 >>>= 2, S2 -= 2;
                  break e;
                }
                break;
              case 2:
                r2.mode = 17;
                break;
              case 3:
                e2.msg = "invalid block type", r2.mode = E;
            }
            Z2 >>>= 2, S2 -= 2;
            break;
          case 14:
            for (Z2 >>>= 7 & S2, S2 -= 7 & S2; S2 < 32; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if ((65535 & Z2) != (Z2 >>> 16 ^ 65535)) {
              e2.msg = "invalid stored block lengths", r2.mode = E;
              break;
            }
            if (r2.length = 65535 & Z2, Z2 = 0, S2 = 0, r2.mode = 15, i2 === w)
              break e;
          case 15:
            r2.mode = 16;
          case 16:
            if (U2 = r2.length, U2) {
              if (U2 > c2 && (U2 = c2), U2 > A2 && (U2 = A2), 0 === U2)
                break e;
              s2.set(o2.subarray(l2, l2 + U2), d2), c2 -= U2, l2 += U2, A2 -= U2, d2 += U2, r2.length -= U2;
              break;
            }
            r2.mode = y;
            break;
          case 17:
            for (; S2 < 14; ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if (r2.nlen = 257 + (31 & Z2), Z2 >>>= 5, S2 -= 5, r2.ndist = 1 + (31 & Z2), Z2 >>>= 5, S2 -= 5, r2.ncode = 4 + (15 & Z2), Z2 >>>= 4, S2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
              e2.msg = "too many length or distance symbols", r2.mode = E;
              break;
            }
            r2.have = 0, r2.mode = 18;
          case 18:
            for (; r2.have < r2.ncode; ) {
              for (; S2 < 3; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              r2.lens[W2[r2.have++]] = 7 & Z2, Z2 >>>= 3, S2 -= 3;
            }
            for (; r2.have < 19; )
              r2.lens[W2[r2.have++]] = 0;
            if (r2.lencode = r2.lendyn, r2.lenbits = 7, G2 = { bits: r2.lenbits }, K2 = f(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, G2), r2.lenbits = G2.bits, K2) {
              e2.msg = "invalid code lengths set", r2.mode = E;
              break;
            }
            r2.have = 0, r2.mode = 19;
          case 19:
            for (; r2.have < r2.nlen + r2.ndist; ) {
              for (; P2 = r2.lencode[Z2 & (1 << r2.lenbits) - 1], C2 = P2 >>> 24, z2 = P2 >>> 16 & 255, F2 = 65535 & P2, !(C2 <= S2); ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              if (F2 < 16)
                Z2 >>>= C2, S2 -= C2, r2.lens[r2.have++] = F2;
              else {
                if (16 === F2) {
                  for (X2 = C2 + 2; S2 < X2; ) {
                    if (0 === c2)
                      break e;
                    c2--, Z2 += o2[l2++] << S2, S2 += 8;
                  }
                  if (Z2 >>>= C2, S2 -= C2, 0 === r2.have) {
                    e2.msg = "invalid bit length repeat", r2.mode = E;
                    break;
                  }
                  j2 = r2.lens[r2.have - 1], U2 = 3 + (3 & Z2), Z2 >>>= 2, S2 -= 2;
                } else if (17 === F2) {
                  for (X2 = C2 + 3; S2 < X2; ) {
                    if (0 === c2)
                      break e;
                    c2--, Z2 += o2[l2++] << S2, S2 += 8;
                  }
                  Z2 >>>= C2, S2 -= C2, j2 = 0, U2 = 3 + (7 & Z2), Z2 >>>= 3, S2 -= 3;
                } else {
                  for (X2 = C2 + 7; S2 < X2; ) {
                    if (0 === c2)
                      break e;
                    c2--, Z2 += o2[l2++] << S2, S2 += 8;
                  }
                  Z2 >>>= C2, S2 -= C2, j2 = 0, U2 = 11 + (127 & Z2), Z2 >>>= 7, S2 -= 7;
                }
                if (r2.have + U2 > r2.nlen + r2.ndist) {
                  e2.msg = "invalid bit length repeat", r2.mode = E;
                  break;
                }
                for (; U2--; )
                  r2.lens[r2.have++] = j2;
              }
            }
            if (r2.mode === E)
              break;
            if (0 === r2.lens[256]) {
              e2.msg = "invalid code -- missing end-of-block", r2.mode = E;
              break;
            }
            if (r2.lenbits = 9, G2 = { bits: r2.lenbits }, K2 = f(1, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, G2), r2.lenbits = G2.bits, K2) {
              e2.msg = "invalid literal/lengths set", r2.mode = E;
              break;
            }
            if (r2.distbits = 6, r2.distcode = r2.distdyn, G2 = { bits: r2.distbits }, K2 = f(2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, G2), r2.distbits = G2.bits, K2) {
              e2.msg = "invalid distances set", r2.mode = E;
              break;
            }
            if (r2.mode = 20, i2 === w)
              break e;
          case 20:
            r2.mode = 21;
          case 21:
            if (c2 >= 6 && A2 >= 258) {
              e2.next_out = d2, e2.avail_out = A2, e2.next_in = l2, e2.avail_in = c2, r2.hold = Z2, r2.bits = S2, a(e2, O2), d2 = e2.next_out, s2 = e2.output, A2 = e2.avail_out, l2 = e2.next_in, o2 = e2.input, c2 = e2.avail_in, Z2 = r2.hold, S2 = r2.bits, r2.mode === y && (r2.back = -1);
              break;
            }
            for (r2.back = 0; P2 = r2.lencode[Z2 & (1 << r2.lenbits) - 1], C2 = P2 >>> 24, z2 = P2 >>> 16 & 255, F2 = 65535 & P2, !(C2 <= S2); ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if (z2 && 0 == (240 & z2)) {
              for (L2 = C2, M2 = z2, H2 = F2; P2 = r2.lencode[H2 + ((Z2 & (1 << L2 + M2) - 1) >> L2)], C2 = P2 >>> 24, z2 = P2 >>> 16 & 255, F2 = 65535 & P2, !(L2 + C2 <= S2); ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              Z2 >>>= L2, S2 -= L2, r2.back += L2;
            }
            if (Z2 >>>= C2, S2 -= C2, r2.back += C2, r2.length = F2, 0 === z2) {
              r2.mode = 26;
              break;
            }
            if (32 & z2) {
              r2.back = -1, r2.mode = y;
              break;
            }
            if (64 & z2) {
              e2.msg = "invalid literal/length code", r2.mode = E;
              break;
            }
            r2.extra = 15 & z2, r2.mode = 22;
          case 22:
            if (r2.extra) {
              for (X2 = r2.extra; S2 < X2; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              r2.length += Z2 & (1 << r2.extra) - 1, Z2 >>>= r2.extra, S2 -= r2.extra, r2.back += r2.extra;
            }
            r2.was = r2.length, r2.mode = 23;
          case 23:
            for (; P2 = r2.distcode[Z2 & (1 << r2.distbits) - 1], C2 = P2 >>> 24, z2 = P2 >>> 16 & 255, F2 = 65535 & P2, !(C2 <= S2); ) {
              if (0 === c2)
                break e;
              c2--, Z2 += o2[l2++] << S2, S2 += 8;
            }
            if (0 == (240 & z2)) {
              for (L2 = C2, M2 = z2, H2 = F2; P2 = r2.distcode[H2 + ((Z2 & (1 << L2 + M2) - 1) >> L2)], C2 = P2 >>> 24, z2 = P2 >>> 16 & 255, F2 = 65535 & P2, !(L2 + C2 <= S2); ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              Z2 >>>= L2, S2 -= L2, r2.back += L2;
            }
            if (Z2 >>>= C2, S2 -= C2, r2.back += C2, 64 & z2) {
              e2.msg = "invalid distance code", r2.mode = E;
              break;
            }
            r2.offset = F2, r2.extra = 15 & z2, r2.mode = 24;
          case 24:
            if (r2.extra) {
              for (X2 = r2.extra; S2 < X2; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              r2.offset += Z2 & (1 << r2.extra) - 1, Z2 >>>= r2.extra, S2 -= r2.extra, r2.back += r2.extra;
            }
            if (r2.offset > r2.dmax) {
              e2.msg = "invalid distance too far back", r2.mode = E;
              break;
            }
            r2.mode = 25;
          case 25:
            if (0 === A2)
              break e;
            if (U2 = O2 - A2, r2.offset > U2) {
              if (U2 = r2.offset - U2, U2 > r2.whave && r2.sane) {
                e2.msg = "invalid distance too far back", r2.mode = E;
                break;
              }
              U2 > r2.wnext ? (U2 -= r2.wnext, D2 = r2.wsize - U2) : D2 = r2.wnext - U2, U2 > r2.length && (U2 = r2.length), I2 = r2.window;
            } else
              I2 = s2, D2 = d2 - r2.offset, U2 = r2.length;
            U2 > A2 && (U2 = A2), A2 -= U2, r2.length -= U2;
            do {
              s2[d2++] = I2[D2++];
            } while (--U2);
            0 === r2.length && (r2.mode = 21);
            break;
          case 26:
            if (0 === A2)
              break e;
            s2[d2++] = r2.length, A2--, r2.mode = 21;
            break;
          case 27:
            if (r2.wrap) {
              for (; S2 < 32; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 |= o2[l2++] << S2, S2 += 8;
              }
              if (O2 -= A2, e2.total_out += O2, r2.total += O2, O2 && (e2.adler = r2.check = r2.flags ? n(r2.check, s2, O2, d2 - O2) : t(r2.check, s2, O2, d2 - O2)), O2 = A2, (r2.flags ? Z2 : R(Z2)) !== r2.check) {
                e2.msg = "incorrect data check", r2.mode = E;
                break;
              }
              Z2 = 0, S2 = 0;
            }
            r2.mode = 28;
          case 28:
            if (r2.wrap && r2.flags) {
              for (; S2 < 32; ) {
                if (0 === c2)
                  break e;
                c2--, Z2 += o2[l2++] << S2, S2 += 8;
              }
              if (Z2 !== (4294967295 & r2.total)) {
                e2.msg = "incorrect length check", r2.mode = E;
                break;
              }
              Z2 = 0, S2 = 0;
            }
            r2.mode = 29;
          case 29:
            K2 = k;
            break e;
          case E:
            K2 = g;
            break e;
          case 31:
            return p;
          case 32:
          default:
            return _;
        }
    return e2.next_out = d2, e2.avail_out = A2, e2.next_in = l2, e2.avail_in = c2, r2.hold = Z2, r2.bits = S2, (r2.wsize || O2 !== e2.avail_out && r2.mode < E && (r2.mode < 27 || i2 !== h)) && N(e2, e2.output, e2.next_out, O2 - e2.avail_out), T2 -= e2.avail_in, O2 -= e2.avail_out, e2.total_in += T2, e2.total_out += O2, r2.total += O2, r2.wrap && O2 && (e2.adler = r2.check = r2.flags ? n(r2.check, s2, O2, e2.next_out - O2) : t(r2.check, s2, O2, e2.next_out - O2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === y ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 === T2 && 0 === O2 || i2 === h) && K2 === b && (K2 = v), K2;
  }, inflateEnd: (e2) => {
    if (!e2 || !e2.state)
      return _;
    let t2 = e2.state;
    return t2.window && (t2.window = null), e2.state = null, b;
  }, inflateGetHeader: (e2, t2) => {
    if (!e2 || !e2.state)
      return _;
    const i2 = e2.state;
    return 0 == (2 & i2.wrap) ? _ : (i2.head = t2, t2.done = false, b);
  }, inflateSetDictionary: (e2, i2) => {
    const n2 = i2.length;
    let a2, r2, o2;
    return e2 && e2.state ? (a2 = e2.state, 0 !== a2.wrap && 11 !== a2.mode ? _ : 11 === a2.mode && (r2 = 1, r2 = t(r2, i2, n2, 0), r2 !== a2.check) ? g : (o2 = N(e2, i2, n2, n2), o2 ? (a2.mode = 31, p) : (a2.havedict = 1, b))) : _;
  }, inflateInfo: "pako inflate (from Nodeca project)" };
  const z = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
  var F = function(e2) {
    const t2 = Array.prototype.slice.call(arguments, 1);
    for (; t2.length; ) {
      const i2 = t2.shift();
      if (i2) {
        if ("object" != typeof i2)
          throw new TypeError(i2 + "must be non-object");
        for (const t3 in i2)
          z(i2, t3) && (e2[t3] = i2[t3]);
      }
    }
    return e2;
  }, L = (e2) => {
    let t2 = 0;
    for (let i3 = 0, n2 = e2.length; i3 < n2; i3++)
      t2 += e2[i3].length;
    const i2 = new Uint8Array(t2);
    for (let t3 = 0, n2 = 0, a2 = e2.length; t3 < a2; t3++) {
      let a3 = e2[t3];
      i2.set(a3, n2), n2 += a3.length;
    }
    return i2;
  };
  let M = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (e2) {
    M = false;
  }
  const H = new Uint8Array(256);
  for (let e2 = 0; e2 < 256; e2++)
    H[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
  H[254] = H[254] = 1;
  var j = (e2) => {
    if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
      return new TextEncoder().encode(e2);
    let t2, i2, n2, a2, r2, o2 = e2.length, s2 = 0;
    for (a2 = 0; a2 < o2; a2++)
      i2 = e2.charCodeAt(a2), 55296 == (64512 & i2) && a2 + 1 < o2 && (n2 = e2.charCodeAt(a2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), a2++)), s2 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
    for (t2 = new Uint8Array(s2), r2 = 0, a2 = 0; r2 < s2; a2++)
      i2 = e2.charCodeAt(a2), 55296 == (64512 & i2) && a2 + 1 < o2 && (n2 = e2.charCodeAt(a2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), a2++)), i2 < 128 ? t2[r2++] = i2 : i2 < 2048 ? (t2[r2++] = 192 | i2 >>> 6, t2[r2++] = 128 | 63 & i2) : i2 < 65536 ? (t2[r2++] = 224 | i2 >>> 12, t2[r2++] = 128 | i2 >>> 6 & 63, t2[r2++] = 128 | 63 & i2) : (t2[r2++] = 240 | i2 >>> 18, t2[r2++] = 128 | i2 >>> 12 & 63, t2[r2++] = 128 | i2 >>> 6 & 63, t2[r2++] = 128 | 63 & i2);
    return t2;
  }, K = (e2, t2) => {
    const i2 = t2 || e2.length;
    if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
      return new TextDecoder().decode(e2.subarray(0, t2));
    let n2, a2;
    const r2 = new Array(2 * i2);
    for (a2 = 0, n2 = 0; n2 < i2; ) {
      let t3 = e2[n2++];
      if (t3 < 128) {
        r2[a2++] = t3;
        continue;
      }
      let o2 = H[t3];
      if (o2 > 4)
        r2[a2++] = 65533, n2 += o2 - 1;
      else {
        for (t3 &= 2 === o2 ? 31 : 3 === o2 ? 15 : 7; o2 > 1 && n2 < i2; )
          t3 = t3 << 6 | 63 & e2[n2++], o2--;
        o2 > 1 ? r2[a2++] = 65533 : t3 < 65536 ? r2[a2++] = t3 : (t3 -= 65536, r2[a2++] = 55296 | t3 >> 10 & 1023, r2[a2++] = 56320 | 1023 & t3);
      }
    }
    return ((e3, t3) => {
      if (t3 < 65534 && e3.subarray && M)
        return String.fromCharCode.apply(null, e3.length === t3 ? e3 : e3.subarray(0, t3));
      let i3 = "";
      for (let n3 = 0; n3 < t3; n3++)
        i3 += String.fromCharCode(e3[n3]);
      return i3;
    })(r2, a2);
  }, P = (e2, t2) => {
    (t2 = t2 || e2.length) > e2.length && (t2 = e2.length);
    let i2 = t2 - 1;
    for (; i2 >= 0 && 128 == (192 & e2[i2]); )
      i2--;
    return i2 < 0 || 0 === i2 ? t2 : i2 + H[e2[i2]] > t2 ? i2 : t2;
  }, Y = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  var G = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  };
  var X = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  };
  const W = Object.prototype.toString, { Z_NO_FLUSH: q, Z_FINISH: J, Z_OK: Q, Z_STREAM_END: V, Z_NEED_DICT: $, Z_STREAM_ERROR: ee, Z_DATA_ERROR: te, Z_MEM_ERROR: ie } = c;
  function ne(e2) {
    this.options = F({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
    const t2 = this.options;
    t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new G(), this.strm.avail_out = 0;
    let i2 = C.inflateInit2(this.strm, t2.windowBits);
    if (i2 !== Q)
      throw new Error(Y[i2]);
    if (this.header = new X(), C.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = j(t2.dictionary) : "[object ArrayBuffer]" === W.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i2 = C.inflateSetDictionary(this.strm, t2.dictionary), i2 !== Q)))
      throw new Error(Y[i2]);
  }
  function ae(e2, t2) {
    const i2 = new ne(t2);
    if (i2.push(e2), i2.err)
      throw i2.msg || Y[i2.err];
    return i2.result;
  }
  ne.prototype.push = function(e2, t2) {
    const i2 = this.strm, n2 = this.options.chunkSize, a2 = this.options.dictionary;
    let r2, o2, s2;
    if (this.ended)
      return false;
    for (o2 = t2 === ~~t2 ? t2 : true === t2 ? J : q, "[object ArrayBuffer]" === W.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
      for (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), r2 = C.inflate(i2, o2), r2 === $ && a2 && (r2 = C.inflateSetDictionary(i2, a2), r2 === Q ? r2 = C.inflate(i2, o2) : r2 === te && (r2 = $)); i2.avail_in > 0 && r2 === V && i2.state.wrap > 0 && 0 !== e2[i2.next_in]; )
        C.inflateReset(i2), r2 = C.inflate(i2, o2);
      switch (r2) {
        case ee:
        case te:
        case $:
        case ie:
          return this.onEnd(r2), this.ended = true, false;
      }
      if (s2 = i2.avail_out, i2.next_out && (0 === i2.avail_out || r2 === V))
        if ("string" === this.options.to) {
          let e3 = P(i2.output, i2.next_out), t3 = i2.next_out - e3, a3 = K(i2.output, e3);
          i2.next_out = t3, i2.avail_out = n2 - t3, t3 && i2.output.set(i2.output.subarray(e3, e3 + t3), 0), this.onData(a3);
        } else
          this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
      if (r2 !== Q || 0 !== s2) {
        if (r2 === V)
          return r2 = C.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, true;
        if (0 === i2.avail_in)
          break;
      }
    }
    return true;
  }, ne.prototype.onData = function(e2) {
    this.chunks.push(e2);
  }, ne.prototype.onEnd = function(e2) {
    e2 === Q && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = L(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
  };
  var re = ne, oe = ae, se = function(e2, t2) {
    return (t2 = t2 || {}).raw = true, ae(e2, t2);
  }, le = ae, de = c, fe = { Inflate: re, inflate: oe, inflateRaw: se, ungzip: le, constants: de };
  e.Inflate = re, e.constants = de, e.default = fe, e.inflate = oe, e.inflateRaw = se, e.ungzip = le, Object.defineProperty(e, "__esModule", { value: true });
});
